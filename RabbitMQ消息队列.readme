
Rabbit对数据一致性要求高,对消息丢失处理较好，优于RocketMQ；

RabbitMQ基于AMQP协议，Advanced Message Queuing Protocol；

RabbitMQ下载安装链接： https://www.rabbitmq.com/download.html；
因为RabbitMQ基于erlang， 所以需要安装erlang环境；
erlang下载地址： https://www.erlang.org/downloads

# linux安装RabbitMQ： https://www.cnblogs.com/gaoyuechen/p/8991243.html
# linux下启动RabbitMQ默认会读取 /etc/rabbitmq/rabbitmq.config文件
    这个文件是不存在的，需要手动创建
   但是rabbitmq提供了配置模板， 模板的位置在：
    /usr/share/doc/rabbitmq-server-版本号/rabbitmq.config.example
# 在/etc/rabbitmq/rabbitmq.config中打开来宾账号, 后面的
 逗号也要去掉{loopback_users, []}
# 启动一些插件，允许使用管理界面:
    sudo rabbitmq-plugins enable rabbitmq_management
# 注意，查看管理端，还需要防火墙添加端口：15672
firewall-cmd --zone=public --add-port=15672/tcp --permanent
firewall-cmd --reload
firewall-cmd --list-ports

# 其他相关命令：
     sudo /sbin/service rabbitmq-server status  # 查看服务状态
     service rabbitmq-server stop
     service rabbitmq-server start

    或者：
        systemctl status rabbitmq-server
        systemctl start rabbitmq-server
        systemctl stop rabbitmq-server
        systemctl restart rabbitmq-server

    rabbitmqctl help  更多命令

    插件命令
    rabbitmq-plugins enable|list|disable


# mac使用brew安装，mac安装后，默认位置： /usr/local/Cellar/rabbitmq/<version>/ ;
erlang也在这个目录下

添加环境变量：
    vim ~/.bashrc
    export PATH=$PATH:/usr/local/sbin


启动rabbitmq： rabbitmq-server

RabbitMQ默认访问链接：http://127.0.0.1:15672/  账户和密码默认是guest guest

可以在admin下添加账户和密码；

# 使用命令行添加用户和权限：

    ## 进入sbin目录
    cd /usr/local/Cellar/rabbitmq/3.7.12/sbin
    ## 添加账号
    ./rabbitmqctl add_user rabbit rabbit
    ## 添加访问权限
    ./rabbitmqctl set_permissions -p "/" rabbit ".*" ".*" ".*"
    ## 设置超管权限
    ./rabbitmqctl set_user_tags rabbit administrator


RabbitMQ角色：
    Publisher Application: 消息生产者
    Consumer Application:消息消费者
    Server: RabbitMQ服务节点
    Virtual Host: 虚拟主机, 相当于mysql中的库, 需要权限，将虚拟主机和用户绑定
    Exchange: 交换机
    Message Queue: 消息队列





消息的发送：
    RabbitMQ消息的发送和消费都是通过通道Channel来操作的，通道需要绑定对应的队列；
    生产者发送消息前需要先和服务器建立心跳包


RabbitMQ模型：
    https://www.rabbitmq.com/getstarted.html
    1. Simple 一个生产者 一个队列 一个消费者 没有交换机（默认交换机）
    2. work queues： 工作队列， 解决消息堆积的问题 一个生产者 一个队列 多个消费者 没有交换机

        多个消费者自动确认消费的情况下， 多个消费者消费的消息是循环模式， 相当于RocketMQ
        中的负载均衡模式，
        如何实现多个消费者的能者多劳模式：
            1. 设置消费者每次只能通过通道获取一个需要消费的消息：
            channel.basicQos(1);
            2. 关闭消费者的消息自动确认消费机制：
            3. 消费者完成消费后，手动确认消息被消费：
             channel.basicConsume("work", false, new DefaultConsumer(channel){

                         @Override
                         public void handleDelivery(String consumerTag,
                                                    Envelope envelope,
                                                    AMQP.BasicProperties properties,
                                                    byte[] body) throws IOException {

                             System.out.println("消费者2： " + new String(body));

                             //模拟消费者2消费较慢
                             try {
                                 TimeUnit.SECONDS.sleep(1);
                             } catch (InterruptedException e) {
                                 e.printStackTrace();
                             }

                             //手动确认
                             //参数1： 手动确认消息的标识
                             //参数2： false： 每次确认一个
                             channel.basicAck(envelope.getDeliveryTag(), false);
                         }
                     });

        3. fanout广播模式： 一个生产者 一个交换机 多个队列 多个队列  多个消费者
            生产者发送消息只需要将消息发送到交换机，
            每个消费者都有自己的临时队列，
            每个临时队列都需要绑定到交换机，
            交换机的类型为广播

        4. routing路由模式 Direct交换机直连：
                相比广播模式，在广播的基础上通过Routing key来制定消费者消费制定队列
                中的消息， 消费者只会消费制定Routing key队列里面的消息
                交换机的类型为Direct直连

        5. Topic模式

